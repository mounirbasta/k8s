name: Verify Deployment Health

on:
  push:
    branches: [ "main" ]
    paths:
      - 'deployments/app-deployment.yaml'

env:
  APP_NAMESPACE: app-dev
  APP_NAME: app
  HEALTH_CHECK_TIMEOUT: 300
  HEALTH_CHECK_INTERVAL: 15

jobs:
  verify-and-rollback:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
      
      - name: Configure kubectl
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
      
      - name: Setup ArgoCD CLI
        uses: clowdhaus/argo-cd-action@v3.1.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          command: version
          options: --client
      
      - name: Login to ArgoCD
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          argocd login $ARGOCD_SERVER \
            --username $ARGOCD_USERNAME \
            --password $ARGOCD_PASSWORD \
            --grpc-web --insecure
      
      - name: Trigger ArgoCD sync for app only
        run: |
          echo "Triggering ArgoCD sync for app deployment..."
          argocd app sync app-dev \
            --resource apps:Deployment:app-dev/app \
            --prune
      
      - name: Wait and check app deployment health
        id: health_check
        run: |
          echo "Monitoring app deployment for up to ${{ env.HEALTH_CHECK_TIMEOUT }} seconds..."
          
          ELAPSED=0
          while [ $ELAPSED -lt ${{ env.HEALTH_CHECK_TIMEOUT }} ]; do
            # Check Kubernetes deployment directly
            READY_REPLICAS=$(kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            DESIRED_REPLICAS=$(kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
            AVAILABLE_REPLICAS=$(kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo "0")
            
            echo "[$ELAPSED s] Ready: $READY_REPLICAS/$DESIRED_REPLICAS | Available: $AVAILABLE_REPLICAS"
            
            # Check for failed conditions
            DEPLOYMENT_STATUS=$(kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Progressing")].status}' 2>/dev/null || echo "Unknown")
            DEPLOYMENT_REASON=$(kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Progressing")].reason}' 2>/dev/null || echo "Unknown")
            
            echo "Deployment Status: $DEPLOYMENT_STATUS, Reason: $DEPLOYMENT_REASON"
            
            # Check if deployment has failed
            if [ "$DEPLOYMENT_REASON" = "ProgressDeadlineExceeded" ]; then
              echo "::error::Deployment failed - progress deadline exceeded"
              kubectl describe deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }}
              kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app=${{ env.APP_NAME }}
              echo "deployment_failed=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Check for success
            if [ "$READY_REPLICAS" = "$DESIRED_REPLICAS" ] && [ "$AVAILABLE_REPLICAS" = "$DESIRED_REPLICAS" ] && [ "$READY_REPLICAS" != "0" ]; then
              echo "Deployment successful! All replicas are ready."
              echo "deployment_failed=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # Show pod status
            echo "Pod status:"
            kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app=${{ env.APP_NAME }} --no-headers | awk '{print "  " $1 ": " $3}'
            
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            ELAPSED=$((ELAPSED + ${{ env.HEALTH_CHECK_INTERVAL }}))
          done
          
          echo "::error::Timeout after ${{ env.HEALTH_CHECK_TIMEOUT }} seconds"
          kubectl describe deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }}
          kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app=${{ env.APP_NAME }}
          echo "deployment_failed=true" >> $GITHUB_OUTPUT
          exit 1
      
      - name: Get pod logs on failure
        if: failure() && steps.health_check.outputs.deployment_failed == 'true'
        run: |
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app=${{ env.APP_NAME }}
          
          echo ""
          echo "=== Pod Logs ==="
          kubectl logs -n ${{ env.APP_NAMESPACE }} -l app=${{ env.APP_NAME }} --tail=100 --all-containers=true || true
          
          echo ""
          echo "=== Pod Events ==="
          kubectl get events -n ${{ env.APP_NAMESPACE }} --sort-by='.lastTimestamp' | grep -i ${{ env.APP_NAME }} | tail -20 || true
      
      - name: Rollback on failure
        if: failure() && steps.health_check.outputs.deployment_failed == 'true'
        run: |
          echo "Deployment failed - rolling back Git commit..."
          
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          BAD_COMMIT=$(git rev-parse HEAD)
          echo "Bad commit: $BAD_COMMIT"
          
          # Check commit type
          PARENT_COUNT=$(git cat-file -p HEAD | grep "^parent" | wc -l)
          
          if [ "$PARENT_COUNT" -gt 1 ]; then
            echo "Merge commit - reverting with mainline 1"
            git revert HEAD --no-edit -m 1
            git push origin main
          else
            echo "Regular commit - using reset"
            git reset --hard HEAD~1
            git push origin main --force-with-lease
          fi
          
          echo "Rollback completed - waiting for ArgoCD to sync..."
          sleep 30
          
          # Verify rollback
          echo "New deployment status:"
          kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.APP_NAMESPACE }}
      
      - name: Notify on success
        if: success()
        run: |
          echo "::notice::Deployment verified successfully - app is healthy"
