name: Verify App Deployment Health

on:
  push:
    branches: [ "main" ]
    paths:
      - 'deployments/app-deployment.yaml'

env:
  ARGOCD_APP_NAME: app-dev
  APP_NAMESPACE: app-dev
  APP_DEPLOYMENT: app
  HEALTH_CHECK_TIMEOUT: 100
  HEALTH_CHECK_INTERVAL: 15

jobs:
  verify-and-rollback:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup ArgoCD CLI
        uses: clowdhaus/argo-cd-action@v3.1.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          command: version
          options: --client
      
      - name: Login to ArgoCD
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          argocd login $ARGOCD_SERVER \
            --username $ARGOCD_USERNAME \
            --password $ARGOCD_PASSWORD \
            --grpc-web --insecure
      
      - name: Wait for any ongoing operations
        run: |
          echo "Checking for ongoing operations..."
          
          # Wait up to 60 seconds for any ongoing operations to complete
          WAIT_TIME=0
          MAX_WAIT=60
          
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            OPERATION_STATE=$(argocd app get ${{ env.ARGOCD_APP_NAME }} -o json | jq -r '.status.operationState.phase // "None"')
            
            if [ "$OPERATION_STATE" = "None" ] || [ "$OPERATION_STATE" = "Succeeded" ] || [ "$OPERATION_STATE" = "Failed" ]; then
              echo "No ongoing operation (state: $OPERATION_STATE)"
              break
            fi
            
            echo "Operation in progress (state: $OPERATION_STATE), waiting..."
            sleep 5
            WAIT_TIME=$((WAIT_TIME + 5))
          done
          
          if [ $WAIT_TIME -ge $MAX_WAIT ]; then
            echo "WARNING: Operation still running after ${MAX_WAIT}s, will proceed anyway"
          fi
      
      - name: Trigger sync if needed
        run: |
          echo "Checking if sync is needed..."
          
          SYNC_STATUS=$(argocd app get ${{ env.ARGOCD_APP_NAME }} -o json | jq -r '.status.sync.status')
          echo "Current sync status: $SYNC_STATUS"
          
          # Only trigger sync if not already in progress and not synced
          if [ "$SYNC_STATUS" != "Synced" ]; then
            echo "Triggering sync..."
            argocd app sync ${{ env.ARGOCD_APP_NAME }} --prune || {
              echo "WARNING: Sync command failed (might be auto-syncing), continuing to health check..."
            }
          else
            echo "App is already synced"
          fi
          
          # Give auto-sync time to start if it's going to
          sleep 5
      
      - name: Monitor app deployment health
        id: health_check
        run: |
          echo "Monitoring deployment: ${{ env.APP_DEPLOYMENT }} in namespace: ${{ env.APP_NAMESPACE }}"
          echo "Checking for up to ${{ env.HEALTH_CHECK_TIMEOUT }} seconds..."
          
          ELAPSED=0
          while [ $ELAPSED -lt ${{ env.HEALTH_CHECK_TIMEOUT }} ]; do
            # Get deployment resource info
            APP_JSON=$(argocd app get ${{ env.ARGOCD_APP_NAME }} -o json)
            
            DEPLOYMENT_INFO=$(echo "$APP_JSON" | jq -r '
              .status.resources[] | 
              select(.kind == "Deployment" and .name == "'"${{ env.APP_DEPLOYMENT }}"'" and .namespace == "'"${{ env.APP_NAMESPACE }}"'")
            ')
            
            # Check if deployment was found
            if [ -z "$DEPLOYMENT_INFO" ] || [ "$DEPLOYMENT_INFO" = "null" ]; then
              echo "[$ELAPSED s] WARNING: Deployment not found in ArgoCD yet, waiting..."
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
              ELAPSED=$((ELAPSED + ${{ env.HEALTH_CHECK_INTERVAL }}))
              continue
            fi
            
            DEPLOYMENT_HEALTH=$(echo "$DEPLOYMENT_INFO" | jq -r '.health.status // "Unknown"')
            DEPLOYMENT_MESSAGE=$(echo "$DEPLOYMENT_INFO" | jq -r '.health.message // "No message"')
            
            # Get operation state
            OPERATION_STATE=$(echo "$APP_JSON" | jq -r '.status.operationState.phase // "None"')
            
            echo "[$ELAPSED s] Health: $DEPLOYMENT_HEALTH | Operation: $OPERATION_STATE"
            
            if [ "$DEPLOYMENT_MESSAGE" != "No message" ]; then
              echo "  Message: $DEPLOYMENT_MESSAGE"
            fi
            
            # Check for FAILURE conditions
            if [ "$DEPLOYMENT_HEALTH" = "Degraded" ]; then
              echo "::error::Deployment is Degraded!"
              echo "Message: $DEPLOYMENT_MESSAGE"
              echo "deployment_failed=true" >> $GITHUB_OUTPUT
              argocd app get ${{ env.ARGOCD_APP_NAME }} || true
              exit 1
            fi
            
            if [ "$DEPLOYMENT_HEALTH" = "Missing" ]; then
              echo "::error::Deployment is Missing!"
              echo "deployment_failed=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Check for SUCCESS
            if [ "$DEPLOYMENT_HEALTH" = "Healthy" ]; then
              echo "SUCCESS: Deployment is Healthy!"
              echo "deployment_failed=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # Still progressing
            if [ "$DEPLOYMENT_HEALTH" = "Progressing" ]; then
              echo "  Deployment is progressing..."
            fi
            
            # Unknown health
            if [ "$DEPLOYMENT_HEALTH" = "Unknown" ]; then
              echo "  Health status is Unknown..."
            fi
            
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            ELAPSED=$((ELAPSED + ${{ env.HEALTH_CHECK_INTERVAL }}))
          done
          
          # Timeout reached - this is a FAILURE
          APP_JSON=$(argocd app get ${{ env.ARGOCD_APP_NAME }} -o json)
          FINAL_HEALTH=$(echo "$APP_JSON" | jq -r '
            .status.resources[] | 
            select(.kind == "Deployment" and .name == "'"${{ env.APP_DEPLOYMENT }}"'" and .namespace == "'"${{ env.APP_NAMESPACE }}"'") |
            .health.status // "Unknown"
          ')
          
          FINAL_MESSAGE=$(echo "$APP_JSON" | jq -r '
            .status.resources[] | 
            select(.kind == "Deployment" and .name == "'"${{ env.APP_DEPLOYMENT }}"'" and .namespace == "'"${{ env.APP_NAMESPACE }}"'") |
            .health.message // "No message"
          ')
          
          echo "::error::TIMEOUT: Deployment did not become healthy after ${{ env.HEALTH_CHECK_TIMEOUT }}s"
          echo "Final health status: $FINAL_HEALTH"
          echo "Final message: $FINAL_MESSAGE"
          
          # Set failure flag for rollback
          echo "deployment_failed=true" >> $GITHUB_OUTPUT
          
          # Show app status
          echo ""
          echo "=== Application Status ==="
          argocd app get ${{ env.ARGOCD_APP_NAME }} || true
          
          exit 1
      
      - name: Show deployment details on failure
        if: failure() && steps.health_check.outputs.deployment_failed == 'true'
        run: |
          echo "=== Deployment Details ==="
          argocd app get ${{ env.ARGOCD_APP_NAME }} -o json | jq -r '
            .status.resources[] | 
            select(.kind == "Deployment" and .name == "'"${{ env.APP_DEPLOYMENT }}"'" and .namespace == "'"${{ env.APP_NAMESPACE }}"'")
          '
          
          echo ""
          echo "=== All app-dev Resources ==="
          argocd app get ${{ env.ARGOCD_APP_NAME }} -o json | jq -r '
            .status.resources[] | 
            select(.namespace == "'"${{ env.APP_NAMESPACE }}"'") |
            "\(.kind)/\(.name): Health=\(.health.status // "N/A")"
          '
      
      - name: Rollback on failure
        if: failure() && steps.health_check.outputs.deployment_failed == 'true'
        run: |
          echo "ROLLBACK: Deployment health check failed - rolling back Git commit..."
          
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          BAD_COMMIT=$(git rev-parse HEAD)
          echo "Rolling back commit: $BAD_COMMIT"
          
          # Check if merge commit
          PARENT_COUNT=$(git cat-file -p HEAD | grep "^parent" | wc -l)
          
          if [ "$PARENT_COUNT" -gt 1 ]; then
            echo "Merge commit - reverting with mainline 1"
            git revert HEAD --no-edit -m 1
            git push origin main
          else
            echo "Regular commit - using reset"
            git reset --hard HEAD~1
            git push origin main --force-with-lease
          fi
          
          echo "SUCCESS: Git rollback completed"
          echo "ArgoCD auto-sync will deploy the previous version"
      
      - name: Notify on success
        if: success()
        run: |
          echo "::notice::SUCCESS: Deployment verified successfully - ${{ env.APP_DEPLOYMENT }} is healthy"
